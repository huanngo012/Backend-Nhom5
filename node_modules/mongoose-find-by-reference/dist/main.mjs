// src/main.ts
import { isValidObjectId } from "mongoose";
var messages = {
  schemaTypeError: {
    "zh-CN": '\u53C2\u6570 "schema" \u7684\u7C7B\u578B\u5F97\u662F "Schema"\u3002',
    "en-US": 'param "schema" type must be "Schema".'
  },
  modelCountError: {
    "zh-CN": "\u94A9\u5B50\u51FD\u6570\u8BBF\u95EE\u5230\u7684 Model \u6570\u91CF\u4E3A 0 \u6216\u8005\u4E0D\u5B58\u5728\u3002",
    "en-US": "The number of models accessed is 0 or does not exist."
  }
};
function i18n(messageId) {
  if (messageId in messages) {
    const message = messages[messageId];
    const lang = (process.env.LANG ?? "").match("CN");
    if (lang)
      return message["zh-CN"];
    else
      return message["en-US"];
  }
}
function MongooseFindByReference(schema) {
  if (schema.constructor.name !== "Schema")
    throw new Error(i18n("schemaTypeError"));
  schema.pre(["find", "findOne", "distinct"], async function(next) {
    const models = this.model.db.models;
    if (Object.keys(models ?? {}).length === 0)
      throw new Error(i18n("modelCountError"));
    const schema2 = this.model.schema;
    function getModel(obj) {
      let refKey = "";
      if (obj?.instance === "ObjectID" || obj?.instance === "ObjectId") {
        const options = obj.options;
        if (options?.ref?.length) {
          refKey = options.ref;
        }
      } else if (obj?.$embeddedSchemaType) {
        return getModel(obj.$embeddedSchemaType);
      }
      return models[refKey];
    }
    function transPath2RefPath(paths, tSchema = schema2) {
      let previousPath = [];
      while (paths.length > 0) {
        const path = paths.shift() ?? "";
        if (tSchema.path([...previousPath, path].join("."))) {
          previousPath.push(path);
        } else {
          const currentModel = getModel(tSchema.path(previousPath.join(".")));
          if (currentModel) {
            const recurseResult = transPath2RefPath(
              [path, ...paths],
              currentModel.schema
            );
            if (!paths.length) {
              return [previousPath.join("."), ...recurseResult];
            } else {
              previousPath.push(...recurseResult);
            }
          } else
            return [...previousPath, path];
        }
      }
      return previousPath;
    }
    `
    Example:
    {
        $and:{
            'owner.name':'Dean',
            'infos.timestamp.createdAt':Date,
        },
        $or:[]
    }`;
    function flatten(dd, separator = ".", prefix = "") {
      `
        { person: { name: "John" } } to { "person.name": "John" }
      `;
      let result = {};
      for (let [k, v] of Object.entries(dd)) {
        let key = prefix ? `${prefix}${separator}${k}` : k;
        if (v.constructor === Object && !Object.keys(v).some((checkKey) => checkKey.startsWith("$"))) {
          let flatObject = flatten(v, separator, key);
          result = { ...result, ...flatObject };
        } else {
          result[key] = v;
        }
      }
      return result;
    }
    async function lookup(prevPaths, conditions, cSchema = schema2) {
      if (typeof conditions !== "object" || conditions === null || Object.keys(conditions).length === 0) {
        return conditions;
      }
      const result = {};
      const prevPathsValue = cSchema.path(prevPaths.join("."));
      for (let [paths, value] of Object.entries(conditions)) {
        if (schema2.path(paths)) {
        } else {
          const reduceResult = [
            ...transPath2RefPath(paths.split(".")),
            value
          ].reduceRight(
            (previousValue, currentValue) => currentValue === "$" ? previousValue : { [currentValue]: previousValue }
          );
          [[paths, value]] = Object.entries(reduceResult);
        }
        const currentPathsArray = paths.startsWith("$") ? paths === "$" ? prevPaths : [] : [...prevPaths, paths];
        const currentPathsString = currentPathsArray.join(".");
        const currentPathsValue = cSchema.path(currentPathsString);
        if (!paths.startsWith("$")) {
          if (currentPathsValue === void 0) {
            const currentModel = getModel(prevPathsValue);
            if (currentModel) {
              const subConditions = await lookup(
                [],
                value,
                currentModel.schema
              );
              if (subConditions) {
                const ids = (await currentModel.find(
                  flatten({ [paths]: subConditions }),
                  "_id"
                )).map((v) => v._id);
                return { $in: ids };
              }
            }
          }
        }
        if (Array.isArray(value))
          Object.assign(result, {
            [paths]: await Promise.all(
              value.map(
                async (v) => await lookup(currentPathsArray, v, cSchema)
              )
            )
          });
        else if (typeof value === "object" && value !== null && Object.keys(value).length > 0 && !isValidObjectId(value))
          Object.assign(result, {
            [paths]: Object.fromEntries(
              await Promise.all(
                Object.entries(value).map(
                  async ([k, v]) => Object.entries(
                    await lookup(
                      currentPathsArray,
                      {
                        [k]: v
                      },
                      cSchema
                    )
                  )[0]
                )
              )
            )
          });
        else
          result[paths] = value;
      }
      return result;
    }
    this._conditions = await lookup([], this._conditions);
    next();
  });
}
export {
  MongooseFindByReference
};
